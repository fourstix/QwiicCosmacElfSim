/*
 * Access data in Qwiic EEPROM or PROGRMEM 
 * to simulate ROM data.
 * 
 * The Qwiic EEPROM is rather slow, so there is a cache
 * in front of it to speed things up.
 */
#if defined QWIIC_EEPROM
//Base address for cache data
//Initialized to invalid value, so cache is always dirty on first read
uint16_t cache_base = ROM_CACHE_DIRTY;

//Cache for EEProm read
uint8_t cache[CACHE_SIZE];

#else
//If we don't have an EEPROM or FRAM, define data in PROGMEM
const uint8_t progmem_rom[] PROGMEM = { 
// The Cosmac Elf spaceship program patched to run in ROM  
// program code (the upper 25% of the screen contains display code)
//0x0000
0x90, 0xB1, 0xB3,
//Patch - go to 0x39 to fix stack
0x30, 0x39,
//Return from patch
0xF8, 0x2D, 0xA3,
0xF8, 0x3F, 0xA2, 0xF8, 0x11, 0xA1, 0xD3, 0x72,
//0x0010
//Patched to keep interrupt cycles and byte count exactly same
0x70, 0x22, 0x78, 0x22, 0x52, 0xC4, 0xE2, 0xE2,
//Patched to set R0 to ROM image location
0xE2, 0x91, 0xB0, 0xF8, 0x00, 0xA0, 0x80, 0xE2,
//0x0020
0xE2, 0x20, 0xA0, 0xE2, 0x20, 0xA0, 0xE2, 0x20,
0xA0, 0x3C, 0x1E, 0x30, 0x0F, 0xE2, 0x69, 0x3F,
//0x0030
//Patch - Toggle Q instead of editing memory (can't write to ROM)
0x2F, 0x37, 0x31, 0xCD, 0x7B, 0x38, 0x7A, 0x30,
//0x7B, 0x30, 0x2F, 
//Patch - fix Stack R2 to point to 0x003F (Ram)
0x2F, 0xF8, 0x00, 0xB2, 0x30, 0x05, 0x00, 0x00,
//0x0040
// bitmap  (the bottom 75% of the screen is the bitmap)
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x7B,   0xDE,   0xDB,   0xDE,   0x00,   0x00,   0x00,   0x00, 
0x4A,   0x50,   0xDA,   0x52,   0x00,   0x00,   0x00,   0x00, 
0x42,   0x5E,   0xAB,   0xD0,   0x00,   0x00,   0x00,   0x00, 
0x4A,   0x42,   0x8A,   0x52,   0x00,   0x00,   0x00,   0x00, 
0x7B,   0xDE,   0x8A,   0x5E,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x07,   0xE0, 
0x00,   0x00,   0x00,   0x00,   0xFF,   0xFF,   0xFF,   0xFF, 
0x00,   0x06,   0x00,   0x01,   0x00,   0x00,   0x00,   0x01, 
0x00,   0x7F,   0xE0,   0x01,   0x00,   0x00,   0x00,   0x02, 
0x7F,   0xC0,   0x3F,   0xE0,   0xFC,   0xFF,   0xFF,   0xFE, 
0x40,   0x0F,   0x00,   0x10,   0x04,   0x80,   0x00,   0x00, 
0x7F,   0xC0,   0x3F,   0xE0,   0x04,   0x80,   0x00,   0x00, 
0x00,   0x3F,   0xD0,   0x40,   0x04,   0x80,   0x00,   0x00, 
0x00,   0x0F,   0x08,   0x20,   0x04,   0x80,   0x7A,   0x1E, 
0x00,   0x00,   0x07,   0x90,   0x04,   0x80,   0x42,   0x10, 
0x00,   0x00,   0x18,   0x7F,   0xFC,   0xF0,   0x72,   0x1C, 
0x00,   0x00,   0x30,   0x00,   0x00,   0x10,   0x42,   0x10, 
0x00,   0x00,   0x73,   0xFC,   0x00,   0x10,   0x7B,   0xD0, 
0x00,   0x00,   0x30,   0x00,   0x3F,   0xF0,   0x00,   0x00, 
0x00,   0x00,   0x18,   0x0F,   0xC0,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x07,   0xF0,   0x00,   0x00,   0x00,   0x00, 
// 0x0100 -- next page 
//EETOPS program patched to run in ROM
    0x30, 0X3B,   // Jump to end to patch the load of R2 to point to ram
    0xf8, 0XFE,   // change this to point to ram with one buffer byte
    0xa2,
    0xe2,
    0x90,
    0xb3,
    0xf8, 0x0c,
    0xa3,
    0xd3,
    0x6c,
    0x64,
    0x22,
    0xa1,
    0x3f, 0x10,
    0x37, 0x12,
    0x6c,
    0x64,
    0x22,
    0xb0,
    0x3f, 0x18,
    0x37, 0x1a,
    0x6c,
    0x64,
    0x22,
    0xa0,
    0x81,
    0x3a, 0x24,
    0xd0,
    0xff, 0x01,
    0x32, 0x29,
    0x7b,
    0x3f, 0x29,
    0x80,
    0x52,
    0x64,
    0x22,
    0x37, 0x2f,
    0x39, 0x35,
    0x6c,
    0x50,
    0x40,
    0x52,
    0x64,
    0x22,
    0x30, 0x29,
    0xF8, 0x00,   // patch to move R2 to RAM
    0xb2,
    0x30, 0x02,
//0x0140 - pad with block of zeros to mark end
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#endif

//Define a functions to access ROM data
#ifdef QWIIC_EEPROM
//Check to see if we are outside the range of the cache
boolean isCacheDirty(uint16_t addr) {
  //Rom base is made from the upper bits
  uint16_t rom_base  = addr & ~ROM_CACHE_MASK; 
  
  //if the current rom base address isn't the cache base
  //then the cache is dirty and needs to be re-filled
  return (rom_base != cache_base);
} // isCacheDirty

//fill the cache with data from base rom address
void fillCache(uint16_t addr) {
  //Rom base is made from the upper bits
  uint16_t rom_base  = addr & ~ROM_CACHE_MASK; 
  
  //Fill cache with next set of bytes from base address
  for(int i = 0; i < CACHE_SIZE; i++) {
    uint16_t offset = (rom_base - ROM_ADDR) + i;
  
    Wire.beginTransmission(EEPROM_ADR);
    //Send address to EEPROM MSB first
    Wire.write((int)(offset >> 8)); // MSB
    Wire.write((int)(offset & 0xFF)); // LSB
    Wire.endTransmission();
    
    //Request data byte
    Wire.requestFrom(EEPROM_ADR, 1);
    
    //Put data in cache
    if (Wire.available()) {
      cache[i] = Wire.read();
    }  // if
  } // for
  //Update cache base for new range
  cache_base = rom_base;  
} // fillCache

//Read from Rom using a cache to speed things up
uint8_t readByteFromRom(uint16_t addr) {
  byte data = 0xFF; 
  //Cache index is made from the lowest bits 
  uint8_t  cache_idx = addr & ROM_CACHE_MASK;

  //Check to see if we are outside the cache range and need re-fill
  if (isCacheDirty(addr)) {
    fillCache(addr);
  } // if isCacheDirty

  //Get data from cache
  data = cache[cache_idx];
  
  return data;
  } // readByteFromRom
#else

//Read byte from ROM image in PROGMEM
uint8_t readByteFromRom(uint16_t addr) {
  uint16_t offset = addr-ROM_ADDR;
  
  return pgm_read_byte_near(progmem_rom + offset); 
} //readByteFromRom
#endif

// Load elf ram buffer with ROM data
void loadRamFromRom() {
  for (int i = 0; i < ELF_RAM_SIZE; i++) 
    elf_ram[i] = readByteFromRom(ROM_ADDR + i);
} // loadVideoRom 



/*
// The orignal Cosmac Elf spaceship program for reference 
const uint8_t spaceship[] PROGMEM = { 
// program code (the upper 25% of the screen contains display code)
0x90, 0xB1, 0xB2, 0xB3, 0xB4, 0xF8, 0x2D, 0xA3,
0xF8, 0x3F, 0xA2, 0xF8, 0x11, 0xA1, 0xD3, 0x72,
//0x0010
0x70, 0x22, 0x78, 0x22, 0x52, 0xC4, 0xC4, 0xC4,
0xF8, 0x00, 0xB0, 0xF8, 0x00, 0xA0, 0x80, 0xE2,
//0x0020
0xE2, 0x20, 0xA0, 0xE2, 0x20, 0xA0, 0xE2, 0x20,
0xA0, 0x3C, 0x1E, 0x30, 0x0F, 0xE2, 0x69, 0x3F,
//0x0030
0x2F, 0x6C, 0xA4, 0x37, 0x33, 0x3F, 0x35, 0x6C,
0x54, 0x14, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00,
//0x0040
// bitmap  (the bottom 75% of the screen is the bitmap)
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x7B,   0xDE,   0xDB,   0xDE,   0x00,   0x00,   0x00,   0x00, 
0x4A,   0x50,   0xDA,   0x52,   0x00,   0x00,   0x00,   0x00, 
0x42,   0x5E,   0xAB,   0xD0,   0x00,   0x00,   0x00,   0x00, 
0x4A,   0x42,   0x8A,   0x52,   0x00,   0x00,   0x00,   0x00, 
0x7B,   0xDE,   0x8A,   0x5E,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x07,   0xE0, 
0x00,   0x00,   0x00,   0x00,   0xFF,   0xFF,   0xFF,   0xFF, 
0x00,   0x06,   0x00,   0x01,   0x00,   0x00,   0x00,   0x01, 
0x00,   0x7F,   0xE0,   0x01,   0x00,   0x00,   0x00,   0x02, 
0x7F,   0xC0,   0x3F,   0xE0,   0xFC,   0xFF,   0xFF,   0xFE, 
0x40,   0x0F,   0x00,   0x10,   0x04,   0x80,   0x00,   0x00, 
0x7F,   0xC0,   0x3F,   0xE0,   0x04,   0x80,   0x00,   0x00, 
0x00,   0x3F,   0xD0,   0x40,   0x04,   0x80,   0x00,   0x00, 
0x00,   0x0F,   0x08,   0x20,   0x04,   0x80,   0x7A,   0x1E, 
0x00,   0x00,   0x07,   0x90,   0x04,   0x80,   0x42,   0x10, 
0x00,   0x00,   0x18,   0x7F,   0xFC,   0xF0,   0x72,   0x1C, 
0x00,   0x00,   0x30,   0x00,   0x00,   0x10,   0x42,   0x10, 
0x00,   0x00,   0x73,   0xFC,   0x00,   0x10,   0x7B,   0xD0, 
0x00,   0x00,   0x30,   0x00,   0x3F,   0xF0,   0x00,   0x00, 
0x00,   0x00,   0x18,   0x0F,   0xC0,   0x00,   0x00,   0x00, 
0x00,   0x00,   0x07,   0xF0,   0x00,   0x00,   0x00,   0x00 
};
*/
